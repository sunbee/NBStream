Proceed in steps as follows:
1. Use only Streamlit widgets to render a quiz item fetched from backend voa AirTable REST API. We can show a quiz question interactively but we encounter limitations of Streamlit's opinionated nature. That means we cannot present a mad-lib in the way we intend, with an input element embedded in a text paragraph. The input text area forces the user to hit Enter to submit an entry, as opposed to evaluation as s/he types in a responsive UX. Streamlit's themes for look-and-feel also do not allow custom styling of individual widgets. How to overcome these limitations? We render an HTML page in an HTML component next.
2. Render simple HTML in 'sui_button.html' using components from Semantic.ui. The resources gives reusable UI elements ("widgets") as well as layouts and collections. The source code (HTML) is downloadable from the site and the integrations (with stylesheets, for example,) are made via CDN files included with script tags. So we have a few buttons and even a grid layout with 3 cards. But the content is static. We want the user to interact with the app. How to include JS for interaction? That's next.
3. Render HTML with CSS and JS in 'sui_button_dyn.html' with JS code developed and tested in CodePen.io. This is Vanilla JS code with classes following observer pattern and two-way bindings between data and UI elements for a responsive UX. We have the Rock-Paper-Scissors game for demonstration. It works, but only in one card. This is because we cut-paste code to reuse in panels resulting in duplicate element IDs in DOM. An element ID should be unique and only the first instance was used in data-bindings so only one panel is operational. We can query DOM using other meta-data such as class-names to retrieve all matching elements, not just the first one. Let's proceed to do that next.
4. Run interactive game of Rock-Paper-Scissors in two panels on the same page, providing isolation in each panel. Retrieve DOM elements for input by class-name into an array. Likewise, retrieve DOM elements for output by class-name in an array. There will be as many elements of each class as there are live panels on the web-page. Create an array of Observables matching the array of input elements. Create an array of Computeds to match the array of output elements, using the factory pattern to provide each Computed instance with a computer tuned to the Observables in its list. Find this implementation in 'sui_button_pan.html' with a dev version in 'sui_button_pnl.html'. Now we have live panels each running a game in isolation. The items required for each panel's operation (2 UI items - input/outut and their Observables) are obtained from 4 arrays with panel no. as index. In this way, we can run as many live panels at a time as we need on one page. The current plan is to run three panels in a grid layout. Proceed to replace Rock-Paper-Scissors with NBS quiz questions.
5. Run an interactive quiz in three panels. The inner HTML in each card in the grid now shows a quiz question. Each panel has one additional Observable for the piece of data that is the expected answer. The Computed is passed both observables in a list during construction - one that wraps around the given answer and the other that wraps around the expected answer. The factory takes care to make the Computed's computer with the correct observables to use in evaluating the result. This keeps the action in each panel isolated and avoids potential issues arising from tag-collision. Note that the computer has one additional task which is to plug the explanation accompanying a question in the common text segment. This is managed by get/set on DOM, wrapping an Observable around the HTML of the explanation for each question and then using the innerHTML attribute to display it in the text segment for the active panel. So far, we have run the quiz from a local HTML file on disk. Now let us create it dynamically from the API.
6. Create templates for the HTML to render in Streamlit with Jinja templating engine. The 'qna.html' has the contents enclosed in HTML body tags in 'base_qna.html'. We will show three panels at a time, so the template has a for loop. Use AirTable API to get all records IDs to store in an array. Only three items can be shown at a time and these will be three consective items from the array referenced by the index of the 1st item. Store the index as a Session State variable for advancement of the deck - one at a time or whole set of three. Enhancements in this step include (a.) async IO for requests to AirTable REST API, shown in contrast with regular synchrous (i.e. sequential) calls, (b.) checkbox to switch between HTML on local disk and HTML generated by templating, and (c.) data in AirTable backend for 4 questions, variants upon one root question, manually inserted. Now we have reached a place where our app renders mad-libs from a database, let us proceed to improve aesthetics and add the functionality to advance through the slide-deck. 

- **rev001**: Add feature to advance the slide-deck. First, list IDs of all quiz items (quiz item = slide) in DB (upto max limit returned by endpoint in one API call). Then, download a subset for rendering in gallery. Use session state to store the current index, which is the position in the list of the 1st of set of slides downloaded for display. The button to advance the slides in forward (reverse) direction increments (decrements) the index, which has a min value of 0. The furthest the index can go is the length of the list of all quiz items minus the number of items picked for rendering in gallery. The advancement mechanism prevents "out of bounds" condition by enforcing this constraint. At any time, the index, stored as a session state variable, determines what items are fetched from DB and "in memory" to show. Implement the functionality for fetching DB content in sync and async mode, prefering async mode to take advantage of concurrency. Streamlit app works, but some content is hard-coded. Each slide is shown as a card (Semantic UI) in a plain grid. Let's tackle these issues next, eliminate the hard-coded quiz content and explore more contemporary styling for our gallery.
- **rev002**: Build an example in Slick Carousel with hard-coded quiz content for future use. Add CSS animation for flip-cards (image on front, mad-lib on back) and use Slick for responsive display of slides in a carousel. Separately, update the Streamlit app to use snaps from DB instead of a single hard-coded gif image. Ensure that the required gif animations are uploaded to Firebase and there is sufficient content in Airtable NBS_NORM and CRUD endpoints documented and tested in Insomnia. Slick seems promising. Next, let's modify HTML templates with reference to the worked-out example to incorporate Slick in Streamlit.
- **rev003**: Incorporate Slick Carousel into Streamlit app. We now have frontend code as follows: (1.) Slick CSS and JS for carousel (2.) Custom CSS for flip-card animation (3.) Custom JS Observer pattern for data-bindings. We also have Semantic UI CSS for styling elements including text display and show/hide buttons. How to deliver this frontend code? CDN! Ref: https://gomakethings.com/how-to-turn-any-github-repo-into-a-cdn/ for converting a Github resource (CSS, JS file) to CDN with a free service from jsdelivr.net ! We have parked the JS and CSS - Slick and custom - in sunbee.github.io (repo) under folder Ashtavarka. Then, we have used attribute href of tag link or attribute src of tag script to incorporate the JS and CSS in our app. THIS IS AMAZING! 

1.
Our approach is taking us down a path of using Streamlit for IO and Vanilla JS-powered HTML page responsive UX. 
2.
The NBS REST API will use Jinja templates to serve an HTML page with stylesheets and JS that we will render in Streamlit.
3.
Streamlit allows rapid prototyping. We want a Single Page App (SPA) in VanillaJS (i.e HTML + CSS + JS). That means implementing CRUD operations to REST API endpoints in Javascript, e.g. using 'fetch()'. We have stylesheets in folder labeled css, JS code in folder labeled JS and HTML in folder labeled templates. The Carousel example in rev002 provides a demonstration based on which we shall flesh out our app as SPA in VanillaJS. 
4.
The basic idea is that the root path of the backend shall return the main page of application. This main page shall have the stylesheets and code delivered via CDN route. The folder for css shall have stylesheets for slick, flip-cards, etc. The folder for JS shall have classes for CRUD, responsive UX, etc. The backend may be Airtable to start and migrated to the FastAPI app when that is complete.


